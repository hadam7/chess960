@using Chess960.Web.Client.Services
@inject ChessGameService GameService
@implements IDisposable

<div class="flex flex-col items-center gap-4">
    <div class="w-full max-w-[600px] aspect-square bg-white/5 rounded-[2rem] shadow-2xl overflow-hidden border-8 border-white/10 relative backdrop-blur-sm">
        <div class="grid grid-cols-8 grid-rows-8 h-full w-full">
            @for (int row = 0; row < 8; row++)
            {
                @for (int col = 0; col < 8; col++)
                {
                    var isFlipped = IsWhiteSide == false;
                    
                    // visual row 0 is top.
                    // If White: Top is Rank 8 (index 7). Row 0 -> Rank 7. Row 7 -> Rank 0.
                    // If Black: Top is Rank 1 (index 0). Row 0 -> Rank 0. Row 7 -> Rank 7.
                    var localRank = isFlipped ? row : 7 - row;
                    
                    // visual col 0 is left.
                    // If White: Left is File A (index 0). Col 0 -> File 0.
                    // If Black: Left is File H (index 7). Col 0 -> File 7.
                    var localFile = isFlipped ? 7 - col : col;

                    var isLightSquare = (localRank + localFile) % 2 != 0;
                    var squareColor = isLightSquare ? "bg-board-white" : "bg-board-black";
                    var piece = GetPieceAt(localFile, localRank);
                    var isSelected = selectedSquare == (localFile, localRank);
                    var isHint = legalMoves.Contains($"{(char)('a' + localFile)}{localRank + 1}");
                    
                    <div class="@squareColor relative flex items-center justify-center @(isSelected ? "ring-4 ring-yellow-400 ring-inset" : "")"
                         @onclick="() => HandleSquareClick(localFile, localRank)">
                        
                        @* Coordinate labels *@
                        @if (col == 0)
                        {
                            <span class="absolute top-0.5 left-0.5 text-[10px] font-bold @(isLightSquare ? "text-board-black" : "text-board-white")">
                                @(localRank + 1)
                            </span>
                        }
                        @if (row == 7)
                        {
                            <span class="absolute bottom-0.5 right-0.5 text-[10px] font-bold @(isLightSquare ? "text-board-black" : "text-board-white")">
                                @((char)('a' + localFile))
                            </span>
                        }

                        @if (piece != ' ')
                        {
                            <ChessPiece PieceType="@char.ToUpper(piece)" 
                                        IsWhite="@char.IsUpper(piece)" 
                                        Class="w-4/5 h-4/5 transition-transform hover:scale-110 z-10" />
                        }

                        @* Hint Dot *@
                        @if (isHint)
                        {
                            <div class="absolute w-1/3 h-1/3 bg-black/20 rounded-full cursor-pointer z-0"></div>
                        }
                    </div>
                }
            }
        </div>
    </div>
    
    @if (!string.IsNullOrEmpty(GameService.GameOverMessage))
    {
        <div class="absolute inset-0 flex items-center justify-center bg-black/50 z-10 rounded-lg">
            <div class="bg-white p-6 rounded-lg shadow-2xl text-center">
                <h2 class="text-2xl font-bold text-red-600 mb-2">Game Over</h2>
                <p class="text-xl font-semibold">@GameService.GameOverMessage</p>
                <button @onclick="() => GameService.StartNewGame(false)" class="mt-4 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">
                    New Game
                </button>
            </div>
        </div>
    }
    else if (GameService.IsCheck)
    {
        <div class="absolute top-2 right-2 bg-red-500 text-white px-3 py-1 rounded-full font-bold shadow-lg animate-pulse z-10">
            CHECK!
        </div>
    }
</div>

@code {
    [Parameter] public bool? IsWhiteSide { get; set; }
    [Parameter] public EventCallback<(string from, string to)> OnMove { get; set; }

    private (int file, int rank)? selectedSquare;
    private HashSet<string> legalMoves = new();
    
    protected override void OnInitialized()
    {
        GameService.OnStateChanged += StateHasChanged;
    }

    public void Dispose()
    {
        GameService.OnStateChanged -= StateHasChanged;
    }

    private char GetPieceAt(int file, int rank)
    {
        var fen = GameService.GetFen();
        if (string.IsNullOrEmpty(fen)) return ' ';

        var parts = fen.Split(' ');
        var ranks = parts[0].Split('/');
        
        if (ranks.Length != 8) return ' ';

        var rankString = ranks[7 - rank];
        
        int currentFile = 0;
        foreach (var c in rankString)
        {
            if (char.IsDigit(c))
            {
                currentFile += (int)char.GetNumericValue(c);
            }
            else
            {
                if (currentFile == file) return c;
                currentFile++;
            }
        }
        return ' ';
    }

    private async Task HandleSquareClick(int file, int rank)
    {
        // If it's not my turn or not my piece (if side is specified), ignore
        if (IsWhiteSide.HasValue)
        {
            var isWhiteTurn = GameService.Game.Pos.SideToMove.IsWhite;
            if (IsWhiteSide.Value != isWhiteTurn) return; // Not my turn
        }

        if (selectedSquare == null)
        {
            // Select piece
            var piece = GetPieceAt(file, rank);
            if (piece != ' ')
            {
                // If side is restricted, only allow selecting own pieces
                if (IsWhiteSide.HasValue)
                {
                    bool isWhitePiece = char.IsUpper(piece);
                    if (IsWhiteSide.Value != isWhitePiece) return;
                }
                
                selectedSquare = (file, rank);
                var fromSquare = $"{(char)('a' + file)}{rank + 1}";
                legalMoves = GameService.GetLegalMovesFor(fromSquare).ToHashSet();
            }
        }
        else
        {
            // Move logic
            var from = $"{(char)('a' + selectedSquare.Value.file)}{selectedSquare.Value.rank + 1}";
            var to = $"{(char)('a' + file)}{rank + 1}";
            
            // Check if it's a valid move (or re-selection)
            if (legalMoves.Contains(to))
            {
                 bool success = GameService.MakeMove(from, to);
                 if (success)
                 {
                     selectedSquare = null;
                     legalMoves.Clear();
                     if (OnMove.HasDelegate)
                     {
                         await OnMove.InvokeAsync((from, to));
                     }
                     return;
                 }
            }

            // If not a valid move (or clicked same square/other piece), standard reselection logic
            var piece = GetPieceAt(file, rank);
            if (piece != ' ')
            {
                // If side is restricted, only allow selecting own pieces
                if (IsWhiteSide.HasValue)
                {
                    bool isWhitePiece = char.IsUpper(piece);
                    if (IsWhiteSide.Value != isWhitePiece) 
                    {
                        selectedSquare = null;
                        legalMoves.Clear();
                        return;
                    }
                }
                
                // If clicking same piece, toggle off? Or just reselect? Let's treat as reselect/new select
                 if (selectedSquare.Value == (file, rank))
                 {
                     selectedSquare = null;
                     legalMoves.Clear();
                 }
                 else
                 {
                     selectedSquare = (file, rank);
                    var fromSquare = $"{(char)('a' + file)}{rank + 1}";
                    legalMoves = GameService.GetLegalMovesFor(fromSquare).ToHashSet();
                 }
            }
            else
            {
                selectedSquare = null;
                legalMoves.Clear();
            }
        }
    }
}
