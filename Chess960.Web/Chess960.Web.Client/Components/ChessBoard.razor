@using Chess960.Web.Client.Services
@inject ChessGameService GameService
@inject PieceThemeService PieceThemeService
@inject AudioService AudioService
@implements IDisposable

<div class="flex flex-col items-center gap-4">
    <div class="w-full aspect-square bg-white/5 rounded-none shadow-2xl overflow-hidden border-8 border-white/10 relative backdrop-blur-sm">
        <div class="grid grid-cols-8 grid-rows-8 h-full w-full">
            @for (int row = 0; row < 8; row++)
            {
                @for (int col = 0; col < 8; col++)
                {
                    var isFlipped = IsWhiteSide == false;
                    
                    // visual row 0 is top.
                    // If White: Top is Rank 8 (index 7). Row 0 -> Rank 7. Row 7 -> Rank 0.
                    // If Black: Top is Rank 1 (index 0). Row 0 -> Rank 0. Row 7 -> Rank 7.
                    var localRank = isFlipped ? row : 7 - row;
                    
                    // visual col 0 is left.
                    // If White: Left is File A (index 0). Col 0 -> File 0.
                    // If Black: Left is File H (index 7). Col 0 -> File 7.
                    var localFile = isFlipped ? 7 - col : col;

                    var isLightSquare = (localRank + localFile) % 2 != 0;
                    var squareColor = isLightSquare ? "bg-board-white" : "bg-board-black";
                    var piece = GetPieceAt(localFile, localRank);
                    var isSelected = selectedSquare == (localFile, localRank);
                    var isHint = legalMoves.Contains($"{(char)('a' + localFile)}{localRank + 1}");
                    
                    <div class="@squareColor relative flex items-center justify-center @(isSelected && !Disabled ? "ring-4 ring-yellow-400 ring-inset" : "") @(Disabled ? "opacity-90 cursor-not-allowed" : "cursor-pointer")"
                         @onclick="() => HandleSquareClick(localFile, localRank)">
                        
                        @* Coordinate labels *@
                        @if (col == 0)
                        {
                            <span class="absolute top-0.5 left-0.5 text-[10px] font-bold @(isLightSquare ? "text-board-black" : "text-board-white")">
                                @(localRank + 1)
                            </span>
                        }
                        @if (row == 7)
                        {
                            <span class="absolute bottom-0.5 right-0.5 text-[10px] font-bold @(isLightSquare ? "text-board-black" : "text-board-white")">
                                @((char)('a' + localFile))
                            </span>
                        }

                        @if (piece != ' ')
                        {
                            <ChessPiece PieceType="@char.ToUpper(piece)" 
                                        IsWhite="@char.IsUpper(piece)" 
                                        Theme="@PieceThemeService.CurrentTheme"
                                        Class="w-4/5 h-4/5 transition-transform hover:scale-110 z-10" />
                        }

                        @* Hint Dot *@
                        @if (isHint)
                        {
                            <div class="absolute w-1/3 h-1/3 bg-black/20 rounded-full cursor-pointer z-0"></div>
                        }
                    </div>
                }
            }
        </div>
    </div>
    

</div>

@code {
    [Parameter] public bool? IsWhiteSide { get; set; }
    [Parameter] public bool Disabled { get; set; }
    [Parameter] public EventCallback<(string from, string to)> OnMove { get; set; }

    private (int file, int rank)? selectedSquare;
    private HashSet<string> legalMoves = new();
    
    protected override async Task OnInitializedAsync()
    {
        GameService.OnStateChanged += RefreshBoard;
        PieceThemeService.OnThemeChanged += StateHasChanged;
        await PieceThemeService.InitializeAsync();
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await AudioService.InitializeAsync();
        }
    }

    protected override void OnParametersSet()
    {
        if (Disabled)
        {
            selectedSquare = null;
            legalMoves.Clear();
        }

        if (!string.IsNullOrEmpty(OverlayFen))
        {
            Console.WriteLine($"[ChessBoard] OverlayFen update: {OverlayFen}");
        }
        UpdateBoardCache();
    }

    private void RefreshBoard()
    {
        UpdateBoardCache();
        _ = AudioService.PlayMove(); // Trigger sound
        StateHasChanged();
    }

    public void Dispose()
    {
        GameService.OnStateChanged -= RefreshBoard;
        PieceThemeService.OnThemeChanged -= StateHasChanged;
    }

    [Parameter] public string? OverlayFen { get; set; }

    private char[,] currentBoard = new char[8, 8];
    private string lastFen = "";

    private void UpdateBoardCache()
    {
        var fen = !string.IsNullOrEmpty(OverlayFen) ? OverlayFen : GameService.GetFen();
        if (fen != lastFen)
        {
            lastFen = fen;
            ParseFenToBoard(fen);
        }
    }

    private void ParseFenToBoard(string fen)
    {
        // Clear board
        for (int i = 0; i < 8; i++)
            for (int j = 0; j < 8; j++)
                currentBoard[i, j] = ' ';

        if (string.IsNullOrEmpty(fen)) return;

        var parts = fen.Split(' ');
        var ranks = parts[0].Split('/');
        
        if (ranks.Length != 8) return;

        for (int rank = 0; rank < 8; rank++)
        {
            var rankString = ranks[7 - rank];
            int file = 0;
            foreach (var c in rankString)
            {
                if (char.IsDigit(c))
                {
                    file += (int)char.GetNumericValue(c);
                }
                else
                {
                    if (file < 8) currentBoard[file, rank] = c;
                    file++;
                }
            }
        }
    }

    private char GetPieceAt(int file, int rank)
    {
        if (file >= 0 && file < 8 && rank >= 0 && rank < 8)
        {
            return currentBoard[file, rank];
        }
        return ' ';
    }
    
    private async Task HandleSquareClick(int file, int rank)
    {
        if (Disabled) return;

        // Disable interaction if viewing history
        if (!string.IsNullOrEmpty(OverlayFen)) return;
        
        // ... existing logic ...
        // If it's not my turn or not my piece (if side is specified), ignore
        if (IsWhiteSide.HasValue)
        {
            var isWhiteTurn = GameService.Game.Pos.SideToMove.IsWhite;
            if (IsWhiteSide.Value != isWhiteTurn) return; // Not my turn
        }

        if (selectedSquare == null)
        {
            // Select piece
            var piece = GetPieceAt(file, rank);
            if (piece != ' ')
            {
                // If side is restricted, only allow selecting own pieces
                if (IsWhiteSide.HasValue)
                {
                    bool isWhitePiece = char.IsUpper(piece);
                    if (IsWhiteSide.Value != isWhitePiece) return;
                }
                
                selectedSquare = (file, rank);
                var fromSquare = $"{(char)('a' + file)}{rank + 1}";
                legalMoves = GameService.GetLegalMovesFor(fromSquare).ToHashSet();
            }
        }
        else
        {
            // Move logic
            var from = $"{(char)('a' + selectedSquare.Value.file)}{selectedSquare.Value.rank + 1}";
            var to = $"{(char)('a' + file)}{rank + 1}";
            
            // Check if it's a valid move (or re-selection)
            if (legalMoves.Contains(to))
            {
                 bool success = GameService.MakeMove(from, to);
                 if (success)
                 {
                     selectedSquare = null;
                     legalMoves.Clear();
                     if (OnMove.HasDelegate)
                     {
                         await OnMove.InvokeAsync((from, to));
                     }
                     return;
                 }
            }

            // If not a valid move (or clicked same square/other piece), standard reselection logic
            var piece = GetPieceAt(file, rank);
            if (piece != ' ')
            {
                // If side is restricted, only allow selecting own pieces
                if (IsWhiteSide.HasValue)
                {
                    bool isWhitePiece = char.IsUpper(piece);
                    if (IsWhiteSide.Value != isWhitePiece) 
                    {
                        selectedSquare = null;
                        legalMoves.Clear();
                        return;
                    }
                }
                
                // If clicking same piece, toggle off? Or just reselect? Let's treat as reselect/new select
                 if (selectedSquare.Value == (file, rank))
                 {
                     selectedSquare = null;
                     legalMoves.Clear();
                 }
                 else
                 {
                     selectedSquare = (file, rank);
                    var fromSquare = $"{(char)('a' + file)}{rank + 1}";
                    legalMoves = GameService.GetLegalMovesFor(fromSquare).ToHashSet();
                 }
            }
            else
            {
                selectedSquare = null;
                legalMoves.Clear();
            }
        }
    }
}
